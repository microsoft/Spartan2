// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: MIT
// This file is part of the Spartan2 project.
// See the LICENSE file in the project root for full license information.
// Source repository: https://github.com/Microsoft/Spartan2

//! This module implements the sum-check protocol used in Spartan.
//!
//! The sum-check protocol allows a prover to convince a verifier that a claimed sum
//! over a multivariate polynomial equals a specific value, without the verifier
//! needing to compute the sum directly.

use crate::{
  CommitmentKey,
  accumulators::{SPARTAN_T_DEGREE, build_accumulators_spartan},
  bellpepper::{
    r1cs::{MultiRoundSpartanWitness, MultiRoundState},
    solver::SatisfyingAssignment,
  },
  eq_linear,
  errors::SpartanError,
  polys::{
    multilinear::MultilinearPolynomial,
    univariate::{CompressedUniPoly, UniPoly},
  },
  r1cs::SplitMultiRoundR1CSShape,
  small_field::SmallValueField,
  start_span,
  traits::{Engine, transcript::TranscriptEngineTrait},
  zk::{NeutronNovaVerifierCircuit, SpartanVerifierCircuit},
};
use ff::Field;
use rayon::prelude::*;
use serde::{Deserialize, Serialize};
use tracing::info;

/// 4 k elements is a good cut-off on a 16-core machine.
const PAR_THRESHOLD: usize = 4 << 10; // 4096

/// Adaptive parallel-for helper.
/// Falls back to a plain `for` loop when the slice is small **or**
/// we are already inside a Rayon worker, avoiding nested pools.
/// `par_for` – run `map(i)` for `i = 0..len` and fold the
/// results with `reduce`, starting from `identity()`.
///
/// When `len` is small or we’re already on a Rayon thread it executes
/// serially; otherwise it uses `into_par_iter`.
fn par_for<R, Map, Red, Id>(len: usize, map: Map, reduce: Red, identity: Id) -> R
where
  R: Send, // result must cross Rayon threads
  Map: Fn(usize) -> R + Sync + Send,
  Red: Fn(R, R) -> R + Sync + Send,
  Id: Fn() -> R + Sync + Send,
{
  // Fast-path for empty ranges
  if len == 0 {
    return identity();
  }

  // Are we *already* running inside a Rayon worker thread?
  let in_rayon_ctx = rayon::current_thread_index().is_some();

  if len < PAR_THRESHOLD || in_rayon_ctx {
    // ---------- serial fallback ----------
    let mut acc = identity();
    for i in 0..len {
      let v = map(i);
      acc = reduce(acc, v);
    }
    acc
  } else {
    // ---------- true parallel path ----------
    (0..len).into_par_iter().map(map).reduce(identity, reduce)
  }
}

/// A proof generated by the sum-check protocol.
///
/// This struct contains the compressed univariate polynomials that constitute
/// the prover's messages in each round of the sum-check protocol.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(bound = "")]
pub struct SumcheckProof<E: Engine> {
  compressed_polys: Vec<CompressedUniPoly<E::Scalar>>,
}

impl<E: Engine> SumcheckProof<E> {
  /// Verifies a sum-check proof.
  ///
  /// # Arguments
  /// * `claim` - The claimed sum that the prover asserts
  /// * `num_rounds` - The number of rounds in the sum-check protocol
  /// * `degree_bound` - The maximum degree of univariate polynomials in each round
  /// * `transcript` - The transcript for the interactive proof
  ///
  /// # Returns
  /// A tuple containing the final evaluation point and the sequence of verifier challenges,
  /// or an error if verification fails.
  pub fn verify(
    &self,
    claim: E::Scalar,
    num_rounds: usize,
    degree_bound: usize,
    transcript: &mut E::TE,
  ) -> Result<(E::Scalar, Vec<E::Scalar>), SpartanError> {
    let (_verify_span, verify_t) = start_span!("sumcheck_verify");
    let mut e = claim;
    let mut r: Vec<E::Scalar> = Vec::new();

    // verify that there is a univariate polynomial for each round
    if self.compressed_polys.len() != num_rounds {
      return Err(SpartanError::InvalidSumcheckProof);
    }

    for i in 0..self.compressed_polys.len() {
      let (_round_span, round_t) = start_span!("sumcheck_verify_round", round = i);
      let poly = self.compressed_polys[i].decompress(&e);

      // verify degree bound
      if poly.degree() != degree_bound {
        return Err(SpartanError::InvalidSumcheckProof);
      }

      // we do not need to check if poly(0) + poly(1) = e, as
      // decompress() call above already ensures that holds
      debug_assert_eq!(poly.eval_at_zero() + poly.eval_at_one(), e);

      // append the prover's message to the transcript
      transcript.absorb(b"p", &poly);

      //derive the verifier's challenge for the next round
      let r_i = transcript.squeeze(b"c")?;

      r.push(r_i);

      // evaluate the claimed degree-ell polynomial at r_i
      e = poly.evaluate(&r_i);

      if round_t.elapsed().as_millis() > 0 {
        info!(elapsed_ms = %round_t.elapsed().as_millis(), "sumcheck_verify_round");
      }
    }

    info!(elapsed_ms = %verify_t.elapsed().as_millis(), "sumcheck_verify");
    Ok((e, r))
  }

  /// Computes evaluation points for a quadratic polynomial in the sum-check protocol.
  ///
  /// Given two multilinear polynomials A and B, computes evaluations at points 0 and 2
  /// of the univariate polynomial formed by binding one variable using a combination function.
  ///
  /// # Arguments
  /// * `poly_A` - First multilinear polynomial
  /// * `poly_B` - Second multilinear polynomial
  /// * `comb_func` - Function combining evaluations of A and B
  ///
  /// # Returns
  /// A tuple `(eval_0, eval_2)` containing evaluations at points 0 and 2.
  #[inline]
  fn compute_eval_points_quad<F>(
    poly_A: &MultilinearPolynomial<E::Scalar>,
    poly_B: &MultilinearPolynomial<E::Scalar>,
    comb_func: &F,
  ) -> (E::Scalar, E::Scalar)
  where
    F: Fn(&E::Scalar, &E::Scalar) -> E::Scalar + Sync,
  {
    let len = poly_A.Z.len() / 2;

    // Using `par_for` keeps the map-reduce logic identical
    // but avoids Rayon overhead on tiny slices.
    par_for(
      len,
      // map-closure (returned pair is the per-index contribution)
      |i| {
        let a_low = poly_A[i];
        let a_high = poly_A[len + i];
        let b_low = poly_B[i];
        let b_high = poly_B[len + i];

        // eval 0:   A(low)
        let eval0 = comb_func(&a_low, &b_low);

        // eval 2:  −A(low) + 2·A(high)   (same for B)
        let a_bound = a_high + a_high - a_low;
        let b_bound = b_high + b_high - b_low;
        let eval2 = comb_func(&a_bound, &b_bound);

        (eval0, eval2)
      },
      // reduce-closure (pairwise accumulation)
      |mut acc, val| {
        acc.0 += val.0;
        acc.1 += val.1;
        acc
      },
      // identity value
      || (E::Scalar::ZERO, E::Scalar::ZERO),
    )
  }

  /// Generates a sum-check proof for a quadratic combination of two multilinear polynomials.
  ///
  /// # Arguments
  /// * `claim` - The claimed sum over the hypercube
  /// * `num_rounds` - The number of variables/rounds in the sum-check
  /// * `poly_A` - First multilinear polynomial (mutable, will be bound during protocol)
  /// * `poly_B` - Second multilinear polynomial (mutable, will be bound during protocol)
  /// * `comb_func` - Function that combines evaluations of the two polynomials
  /// * `transcript` - The transcript for generating randomness
  ///
  /// # Returns
  /// A tuple containing the sum-check proof, the sequence of verifier challenges,
  /// and the final evaluations of the polynomials.
  pub fn prove_quad<F>(
    claim: &E::Scalar,
    num_rounds: usize,
    poly_A: &mut MultilinearPolynomial<E::Scalar>,
    poly_B: &mut MultilinearPolynomial<E::Scalar>,
    comb_func: F,
    transcript: &mut E::TE,
  ) -> Result<(Self, Vec<E::Scalar>, Vec<E::Scalar>), SpartanError>
  where
    F: Fn(&E::Scalar, &E::Scalar) -> E::Scalar + Sync,
  {
    let mut r: Vec<E::Scalar> = Vec::new();
    let mut polys: Vec<CompressedUniPoly<E::Scalar>> = Vec::new();
    let mut claim_per_round = *claim;
    for round in 0..num_rounds {
      let (_round_span, round_t) = start_span!("sumcheck_quad_round", round = round);

      let poly = {
        let (_eval_span, eval_t) = start_span!("compute_eval_points_quad");
        let (eval_point_0, eval_point_2) =
          Self::compute_eval_points_quad(poly_A, poly_B, &comb_func);
        if eval_t.elapsed().as_millis() > 0 {
          info!(elapsed_ms = %eval_t.elapsed().as_millis(), "compute_eval_points_quad");
        }

        let evals = vec![eval_point_0, claim_per_round - eval_point_0, eval_point_2];
        UniPoly::from_evals(&evals)?
      };

      // append the prover's message to the transcript
      transcript.absorb(b"p", &poly);

      //derive the verifier's challenge for the next round
      let r_i = transcript.squeeze(b"c")?;
      r.push(r_i);
      polys.push(poly.compress());

      // Set up next round
      claim_per_round = poly.evaluate(&r_i);

      // bind all tables to the verifier's challenge
      let (_bind_span, bind_t) = start_span!("bind_poly_vars_quad");
      rayon::join(
        || poly_A.bind_poly_var_top(&r_i),
        || poly_B.bind_poly_var_top(&r_i),
      );
      info!(elapsed_ms = %bind_t.elapsed().as_millis(), "bind_poly_vars_quad");
      info!(elapsed_ms = %round_t.elapsed().as_millis(), round = round, "sumcheck_quad_round");
    }

    Ok((
      SumcheckProof {
        compressed_polys: polys,
      },
      r,
      vec![poly_A[0], poly_B[0]],
    ))
  }

  #[inline]
  /// Computes evaluation points for a cubic polynomial with additive term.
  ///
  /// This function computes three evaluation points (at 0, 2, and 3) for a univariate
  /// polynomial that represents the sum over a hypercube edge in the sum-check protocol
  /// for a cubic combination of four multilinear polynomials.
  ///
  /// # Arguments
  /// * `poly_A` - First multilinear polynomial
  /// * `poly_B` - Second multilinear polynomial
  /// * `poly_C` - Third multilinear polynomial
  /// * `poly_D` - Fourth multilinear polynomial
  /// * `comb_func` - Function that combines evaluations of the four polynomials
  ///
  /// # Returns
  /// A tuple containing the evaluations at points 0, 2, and 3.
  fn compute_eval_points_cubic_with_additive_term<F>(
    poly_A: &MultilinearPolynomial<E::Scalar>,
    poly_B: &MultilinearPolynomial<E::Scalar>,
    poly_C: &MultilinearPolynomial<E::Scalar>,
    poly_D: &MultilinearPolynomial<E::Scalar>,
    comb_func: &F,
  ) -> (E::Scalar, E::Scalar, E::Scalar)
  where
    F: Fn(&E::Scalar, &E::Scalar, &E::Scalar, &E::Scalar) -> E::Scalar + Sync,
  {
    let len = poly_B.Z.len() / 2;
    par_for(
      len,
      |i| {
        let a_low = poly_A[i];
        let a_high = poly_A[i + len];
        let b_low = poly_B[i];
        let b_high = poly_B[i + len];
        let c_low = poly_C[i];
        let c_high = poly_C[i + len];
        let d_low = poly_D[i];
        let d_high = poly_D[i + len];

        // eval 0: bound_func is A(low)
        let eval_point_0 = comb_func(&a_low, &b_low, &c_low, &d_low);

        // eval 2: bound_func is -A(low) + 2*A(high)
        let poly_A_bound_point = a_high + a_high - a_low;
        let poly_B_bound_point = b_high + b_high - b_low;
        let poly_C_bound_point = c_high + c_high - c_low;
        let poly_D_bound_point = d_high + d_high - d_low;
        let eval_point_2 = comb_func(
          &poly_A_bound_point,
          &poly_B_bound_point,
          &poly_C_bound_point,
          &poly_D_bound_point,
        );

        // eval 3: bound_func is -2A(low) + 3A(high); computed incrementally with bound_func applied to eval(2)
        let poly_A_bound_point = poly_A_bound_point + a_high - a_low;
        let poly_B_bound_point = poly_B_bound_point + b_high - b_low;
        let poly_C_bound_point = poly_C_bound_point + c_high - c_low;
        let poly_D_bound_point = poly_D_bound_point + d_high - d_low;
        let eval_point_3 = comb_func(
          &poly_A_bound_point,
          &poly_B_bound_point,
          &poly_C_bound_point,
          &poly_D_bound_point,
        );
        (eval_point_0, eval_point_2, eval_point_3)
      },
      |mut acc, val| {
        acc.0 += val.0;
        acc.1 += val.1;
        acc.2 += val.2;
        acc
      },
      || (E::Scalar::ZERO, E::Scalar::ZERO, E::Scalar::ZERO),
    )
  }

  #[inline]
  /// Computes evaluation points for a cubic polynomial with additive term.
  /// The outer polynomial is the power of tau, which is an outer product of two polynomials left and right.
  ///
  /// This function computes three evaluation points (at 0, 2, and 3) for a univariate
  /// polynomial that represents the sum over a hypercube edge in the sum-check protocol
  /// for a cubic combination of three multilinear polynomials.
  ///
  /// # Arguments
  /// * `pow_tau_left` - The left part of the power of tau
  /// * `pow_tau_right` - The right part of the power of tau
  /// * `poly_A` - First multilinear polynomial
  /// * `poly_B` - Second multilinear polynomial
  /// * `poly_C` - Third multilinear polynomial
  /// * `comb_func` - Function that combines evaluations of the four polynomials
  ///
  /// # Returns
  /// A tuple containing the evaluations at points 0, 2, and 3.
  fn compute_eval_points_cubic_with_additive_term_with_outer_pow<F>(
    pow_tau_left: &MultilinearPolynomial<E::Scalar>,
    pow_tau_right: &MultilinearPolynomial<E::Scalar>,
    poly_A: &MultilinearPolynomial<E::Scalar>,
    poly_B: &MultilinearPolynomial<E::Scalar>,
    poly_C: &MultilinearPolynomial<E::Scalar>,
    comb_func: &F,
  ) -> (E::Scalar, E::Scalar, E::Scalar)
  where
    F: Fn(&E::Scalar, &E::Scalar, &E::Scalar, &E::Scalar) -> E::Scalar + Sync,
  {
    let len = poly_A.Z.len() / 2;
    let left = pow_tau_left.Z.len();

    if len < left {
      return Self::compute_eval_points_cubic_with_additive_term(
        pow_tau_left,
        poly_A,
        poly_B,
        poly_C,
        comb_func,
      );
    }

    let right = len / left;

    par_for(
      left,
      |i| {
        let pow_left = pow_tau_left[i];

        let mut acc_0 = E::Scalar::ZERO;
        let mut acc_2 = E::Scalar::ZERO;
        let mut acc_3 = E::Scalar::ZERO;

        for j in 0..right {
          let low = i + j * left;
          let high = low + len;

          let tau_low_right = pow_tau_right[j];
          let tau_high_right = pow_tau_right[j + right];

          let a_low = poly_A[low];
          let a_high = poly_A[high];
          let b_low = poly_B[low];
          let b_high = poly_B[high];
          let c_low = poly_C[low];
          let c_high = poly_C[high];

          // eval 0: bound_func is A(low)
          let eval_point_0 = comb_func(&tau_low_right, &a_low, &b_low, &c_low);

          // eval 2: bound_func is -A(low) + 2*A(high)
          let poly_tau_bound_point = tau_high_right + tau_high_right - tau_low_right;
          let poly_A_bound_point = a_high + a_high - a_low;
          let poly_B_bound_point = b_high + b_high - b_low;
          let poly_C_bound_point = c_high + c_high - c_low;
          let eval_point_2 = comb_func(
            &poly_tau_bound_point,
            &poly_A_bound_point,
            &poly_B_bound_point,
            &poly_C_bound_point,
          );

          // eval 3: bound_func is -2A(low) + 3A(high); computed incrementally with bound_func applied to eval(2)
          let poly_tau_bound_point = poly_tau_bound_point + tau_high_right - tau_low_right;
          let poly_A_bound_point = poly_A_bound_point + a_high - a_low;
          let poly_B_bound_point = poly_B_bound_point + b_high - b_low;
          let poly_C_bound_point = poly_C_bound_point + c_high - c_low;
          let eval_point_3 = comb_func(
            &poly_tau_bound_point,
            &poly_A_bound_point,
            &poly_B_bound_point,
            &poly_C_bound_point,
          );

          acc_0 += eval_point_0;
          acc_2 += eval_point_2;
          acc_3 += eval_point_3;
        }

        (acc_0 * pow_left, acc_2 * pow_left, acc_3 * pow_left)
      },
      |mut acc, val| {
        acc.0 += val.0;
        acc.1 += val.1;
        acc.2 += val.2;
        acc
      },
      || (E::Scalar::ZERO, E::Scalar::ZERO, E::Scalar::ZERO),
    )
  }

  /// Prove poly_A * poly_B - poly_C using optimized equality polynomial handling
  pub fn prove_cubic_with_three_inputs(
    claim: &E::Scalar,
    taus: Vec<E::Scalar>,
    poly_A: &mut MultilinearPolynomial<E::Scalar>,
    poly_B: &mut MultilinearPolynomial<E::Scalar>,
    poly_C: &mut MultilinearPolynomial<E::Scalar>,
    transcript: &mut E::TE,
  ) -> Result<(Self, Vec<E::Scalar>, Vec<E::Scalar>), SpartanError> {
    let mut r: Vec<E::Scalar> = Vec::new();
    let mut polys: Vec<CompressedUniPoly<E::Scalar>> = Vec::new();
    let mut claim_per_round = *claim;

    let num_rounds = taus.len();

    let mut eq_instance = eq_sumcheck::EqSumCheckInstance::<E>::new(taus);

    for round in 0..num_rounds {
      let (_round_span, round_t) = start_span!("sumcheck_round", round = round);

      let poly = {
        // Make an iterator returning the contributions to the evaluations
        let (_eval_span, eval_t) = start_span!("compute_eval_points");
        let (eval_point_0, eval_point_2, eval_point_3) =
          eq_instance.evaluation_points_cubic_with_three_inputs(round, poly_A, poly_B, poly_C);
        if eval_t.elapsed().as_millis() > 0 {
          info!(elapsed_ms = %eval_t.elapsed().as_millis(), "compute_eval_points");
        }

        let evals = vec![
          eval_point_0,
          claim_per_round - eval_point_0,
          eval_point_2,
          eval_point_3,
        ];
        UniPoly::from_evals(&evals)?
      };

      // append the prover's message to the transcript
      transcript.absorb(b"p", &poly);

      //derive the verifier's challenge for the next round
      let r_i = transcript.squeeze(b"c")?;
      r.push(r_i);
      polys.push(poly.compress());

      // Set up next round
      claim_per_round = poly.evaluate(&r_i);

      // bound all tables to the verifier's challenge
      let (_bind_span, bind_t) = start_span!("bind_poly_vars");
      rayon::join(
        || poly_A.bind_poly_var_top(&r_i),
        || poly_B.bind_poly_var_top(&r_i),
      );
      rayon::join(
        || poly_C.bind_poly_var_top(&r_i),
        || eq_instance.bound(&r_i),
      );
      info!(elapsed_ms = %bind_t.elapsed().as_millis(), "bind_poly_vars");
      info!(elapsed_ms = %round_t.elapsed().as_millis(), round = round, "sumcheck_round");
    }

    Ok((
      SumcheckProof {
        compressed_polys: polys,
      },
      r,
      vec![poly_A[0], poly_B[0], poly_C[0]],
    ))
  }

  /// Default number of small-value rounds (ℓ₀) for Algorithm 6.
  /// Optimal value from paper analysis for Spartan with D=2.
  const DEFAULT_SMALL_VALUE_ROUNDS: usize = 3;

  /// Prove poly_A * poly_B - poly_C using Algorithm 6 (EqPoly-SmallValueSC).
  ///
  /// This method combines small-value optimization (Algorithm 4) for the first ℓ₀ rounds
  /// with eq-poly optimization (Algorithm 5) for the remaining rounds.
  ///
  /// # Arguments
  /// * `claim` - The claimed sum
  /// * `taus` - Random challenges for the eq polynomial
  /// * `poly_A_small` - Small-value polynomial (evaluations must fit in i32)
  /// * `poly_B_small` - Small-value polynomial (evaluations must fit in i32)
  /// * `poly_A` - Field-element polynomial (same values as poly_A_small, for binding)
  /// * `poly_B` - Field-element polynomial (same values as poly_B_small, for binding)
  /// * `poly_C` - Field-element polynomial for the subtractive term
  /// * `transcript` - The transcript for Fiat-Shamir
  ///
  /// The small-value polynomials are used for efficient ss/sl multiplications in
  /// the accumulator building phase. The field-element polynomials are used for
  /// binding after the small-value rounds.
  #[allow(dead_code)]
  pub fn prove_cubic_with_three_inputs_small_value(
    claim: &E::Scalar,
    taus: Vec<E::Scalar>,
    poly_A_small: &MultilinearPolynomial<i32>,
    poly_B_small: &MultilinearPolynomial<i32>,
    poly_A: &mut MultilinearPolynomial<E::Scalar>,
    poly_B: &mut MultilinearPolynomial<E::Scalar>,
    poly_C: &mut MultilinearPolynomial<E::Scalar>,
    transcript: &mut E::TE,
  ) -> Result<(Self, Vec<E::Scalar>, Vec<E::Scalar>), SpartanError>
  where
    E::Scalar: SmallValueField<SmallValue = i32, IntermediateSmallValue = i64>,
  {
    let mut r: Vec<E::Scalar> = Vec::new();
    let mut polys: Vec<CompressedUniPoly<E::Scalar>> = Vec::new();
    let mut claim_per_round = *claim;

    let num_rounds = taus.len();

    // Determine ℓ₀: must satisfy l0 <= num_rounds / 2
    let l0 = std::cmp::min(Self::DEFAULT_SMALL_VALUE_ROUNDS, num_rounds / 2);

    // If l0 is 0, fall back to standard algorithm
    if l0 == 0 {
      return Self::prove_cubic_with_three_inputs(claim, taus, poly_A, poly_B, poly_C, transcript);
    }

    // ===== Pre-computation Phase =====
    // Build accumulators A_i(v, u) for all i ∈ [ℓ₀] using small-value arithmetic
    // ss: i32 × i32 → i64 for polynomial products
    // isl: i64 × field for eq weighting
    let accumulators = build_accumulators_spartan(poly_A_small, poly_B_small, &taus, l0);
    let mut small_value =
      lagrange_sumcheck::SmallValueSumCheck::<E::Scalar, SPARTAN_T_DEGREE>::from_accumulators(
        accumulators,
      );

    // ===== Small-Value Rounds (0 to ℓ₀-1) =====
    // During these rounds, we use the precomputed accumulators. Polynomials are NOT bound
    // during these rounds - that will happen in the transition phase.
    #[allow(clippy::needless_range_loop)]
    for round in 0..l0 {
      let (_round_span, round_t) = start_span!("sumcheck_smallvalue_round", round = round);

      // 1. Get t_i evaluations from accumulators
      let t_all = small_value.eval_t_all_u(round);
      let t_inf = t_all.at_infinity();
      let t0 = t_all.at_zero();

      // 2. Get eq factor values ℓ_i(0), ℓ_i(1), ℓ_i(∞)
      let li = small_value.eq_round_values(taus[round]);

      // 3. Derive t(1) from sumcheck constraint: s(0) + s(1) = claim
      let t1 = eq_linear::derive_t1(li.at_zero(), li.at_one(), claim_per_round, t0)
        .ok_or(SpartanError::InvalidSumcheckProof)?;

      // 4. Build round polynomial s_i(X) = ℓ_i(X) · t_i(X)
      let poly = lagrange_sumcheck::build_univariate_round_polynomial(&li, t0, t1, t_inf);

      // 5. Transcript interaction
      transcript.absorb(b"p", &poly);
      let r_i = transcript.squeeze(b"c")?;
      r.push(r_i);
      polys.push(poly.compress());

      // 6. Update claim
      claim_per_round = poly.evaluate(&r_i);

      // 7. Advance small-value state (updates R_{i+1} and eq_factor)
      small_value.advance(&li, r_i);

      info!(
        elapsed_ms = %round_t.elapsed().as_millis(),
        round = round,
        "sumcheck_smallvalue_round"
      );
    }

    // ===== Transition Phase =====
    // Create EqSumCheckInstance with ALL taus and advance it by l0 rounds.
    // This ensures the internal partition and state matches the standard method exactly.
    let mut eq_instance = eq_sumcheck::EqSumCheckInstance::<E>::new(taus.clone());

    // Bind all three polynomials to challenges r[0..l0] and advance eq_instance
    // This brings everything to the same state as if we had run the standard method for l0 rounds
    let (_bind_span, bind_t) = start_span!("bind_poly_vars_transition");
    #[allow(clippy::needless_range_loop)]
    for i in 0..l0 {
      rayon::join(
        || poly_A.bind_poly_var_top(&r[i]),
        || poly_B.bind_poly_var_top(&r[i]),
      );
      rayon::join(
        || poly_C.bind_poly_var_top(&r[i]),
        || eq_instance.bound(&r[i]),
      );
    }
    info!(
      elapsed_ms = %bind_t.elapsed().as_millis(),
      "bind_poly_vars_transition"
    );

    // ===== Remaining Rounds (ℓ₀ to ℓ-1) =====
    // Continue using the same eq_instance which is now in the correct state
    for round in l0..num_rounds {
      let (_round_span, round_t) = start_span!("sumcheck_round", round = round);

      let poly = {
        let (_eval_span, eval_t) = start_span!("compute_eval_points");
        let (eval_point_0, eval_point_2, eval_point_3) =
          eq_instance.evaluation_points_cubic_with_three_inputs(round, poly_A, poly_B, poly_C);
        if eval_t.elapsed().as_millis() > 0 {
          info!(elapsed_ms = %eval_t.elapsed().as_millis(), "compute_eval_points");
        }

        let evals = vec![
          eval_point_0,
          claim_per_round - eval_point_0,
          eval_point_2,
          eval_point_3,
        ];
        UniPoly::from_evals(&evals)?
      };

      // Transcript interaction
      transcript.absorb(b"p", &poly);
      let r_i = transcript.squeeze(b"c")?;
      r.push(r_i);
      polys.push(poly.compress());

      // Update claim
      claim_per_round = poly.evaluate(&r_i);

      // Bind polynomials and advance eq instance
      let (_bind_span, bind_t) = start_span!("bind_poly_vars");
      rayon::join(
        || poly_A.bind_poly_var_top(&r_i),
        || poly_B.bind_poly_var_top(&r_i),
      );
      rayon::join(
        || poly_C.bind_poly_var_top(&r_i),
        || eq_instance.bound(&r_i),
      );
      info!(elapsed_ms = %bind_t.elapsed().as_millis(), "bind_poly_vars");
      info!(elapsed_ms = %round_t.elapsed().as_millis(), round = round, "sumcheck_round");
    }

    Ok((
      SumcheckProof {
        compressed_polys: polys,
      },
      r,
      vec![poly_A[0], poly_B[0], poly_C[0]],
    ))
  }

  /// Executes the **outer** cubic-with-additive-term sum-check in
  /// Zero-knowledge outer sum-check for the cubic-with-additive-term case.
  pub fn prove_cubic_with_additive_term_zk(
    num_rounds: usize,
    taus: &[E::Scalar],
    poly_Az: &mut MultilinearPolynomial<E::Scalar>,
    poly_Bz: &mut MultilinearPolynomial<E::Scalar>,
    poly_Cz: &mut MultilinearPolynomial<E::Scalar>,
    verifier_circuit: &mut SpartanVerifierCircuit<E>,
    state: &mut MultiRoundState<E>,
    vc_shape: &SplitMultiRoundR1CSShape<E>,
    vc_ck: &CommitmentKey<E>,
    transcript: &mut E::TE,
  ) -> Result<Vec<E::Scalar>, SpartanError> {
    let mut r_x: Vec<E::Scalar> = Vec::with_capacity(num_rounds);
    let mut claim_outer_round = E::Scalar::ZERO;
    let mut eq_instance = eq_sumcheck::EqSumCheckInstance::<E>::new(taus.to_vec());

    for i in 0..num_rounds {
      // -------- interpolate coefficients --------

      let (eval0, eval2, eval3) =
        eq_instance.evaluation_points_cubic_with_three_inputs(i, poly_Az, poly_Bz, poly_Cz);
      let evals = vec![eval0, claim_outer_round - eval0, eval2, eval3];
      let poly = UniPoly::from_evals(&evals)?;
      verifier_circuit.outer_polys[i] = [
        poly.coeffs[0],
        poly.coeffs[1],
        poly.coeffs[2],
        poly.coeffs[3],
      ];

      // -------- transcript / witness handling --------
      let chals = SatisfyingAssignment::<E>::process_round(
        state,
        vc_shape,
        vc_ck,
        verifier_circuit,
        i,
        transcript,
      )?;
      r_x.push(chals[0]);

      // -------- advance claim and bind polys --------
      claim_outer_round = poly.evaluate(&chals[0]);

      rayon::join(
        || poly_Az.bind_poly_var_top(&chals[0]),
        || {
          rayon::join(
            || poly_Bz.bind_poly_var_top(&chals[0]),
            || poly_Cz.bind_poly_var_top(&chals[0]),
          );
        },
      );
      eq_instance.bound(&chals[0]);
    }

    Ok(r_x)
  }

  /// Executes a **quadratic** sum-check in zero-knowledge mode and returns the
  /// Zero-knowledge quadratic sum-check used for the inner round.
  pub fn prove_quad_zk(
    claim: &E::Scalar,
    num_rounds: usize,
    poly_ABC: &mut MultilinearPolynomial<E::Scalar>,
    poly_z: &mut MultilinearPolynomial<E::Scalar>,
    verifier_circuit: &mut SpartanVerifierCircuit<E>,
    state: &mut MultiRoundState<E>,
    vc_shape: &SplitMultiRoundR1CSShape<E>,
    vc_ck: &CommitmentKey<E>,
    transcript: &mut E::TE,
    start_round: usize,
  ) -> Result<(Vec<E::Scalar>, Vec<E::Scalar>), SpartanError> {
    let mut r_y: Vec<E::Scalar> = Vec::with_capacity(num_rounds);
    let mut claim_current_round = *claim;

    for j in 0..num_rounds {
      // -------- interpolate coeffs --------
      let comb = |a: &E::Scalar, b: &E::Scalar| -> E::Scalar { *a * *b };
      let (eval0, eval2) = Self::compute_eval_points_quad(poly_ABC, poly_z, &comb);
      let evals = vec![eval0, claim_current_round - eval0, eval2];
      let poly = UniPoly::from_evals(&evals)?;

      verifier_circuit.inner_polys[j] = [poly.coeffs[0], poly.coeffs[1], poly.coeffs[2]];

      // -------- transcript / witness handling --------
      let chals = SatisfyingAssignment::<E>::process_round(
        state,
        vc_shape,
        vc_ck,
        verifier_circuit,
        start_round + j,
        transcript,
      )?;
      r_y.push(chals[0]);

      // -------- bind polys --------
      rayon::join(
        || poly_ABC.bind_poly_var_top(&chals[0]),
        || poly_z.bind_poly_var_top(&chals[0]),
      );

      // -------- advance claim for next round --------
      claim_current_round = poly.evaluate(&chals[0]);
    }

    Ok((r_y, vec![poly_ABC[0], poly_z[0]]))
  }

  /// Executes a **quadratic** batched sum-check in zero-knowledge mode and returns the
  /// sequence of verifier challenges used for the inner round.
  pub fn prove_quad_batched_zk(
    claims: &[E::Scalar; 2],
    num_rounds: usize,
    poly_A_0: &mut MultilinearPolynomial<E::Scalar>,
    poly_A_1: &mut MultilinearPolynomial<E::Scalar>,
    poly_B_0: &mut MultilinearPolynomial<E::Scalar>,
    poly_B_1: &mut MultilinearPolynomial<E::Scalar>,
    verifier_circuit: &mut NeutronNovaVerifierCircuit<E>,
    state: &mut MultiRoundState<E>,
    vc_shape: &SplitMultiRoundR1CSShape<E>,
    vc_ck: &CommitmentKey<E>,
    transcript: &mut E::TE,
    start_round: usize,
  ) -> Result<(Vec<E::Scalar>, Vec<E::Scalar>), SpartanError> {
    let mut r_y: Vec<E::Scalar> = Vec::with_capacity(num_rounds);
    // Maintain separate claims for step and core branches
    let mut claim_step_round = claims[0];
    let mut claim_core_round = claims[1];

    for j in 0..num_rounds {
      // -------- interpolate coeffs --------
      let comb = |a: &E::Scalar, b: &E::Scalar| -> E::Scalar { *a * *b };

      let ((eval0_s, eval2_s), (eval0_c, eval2_c)) = rayon::join(
        || Self::compute_eval_points_quad(poly_A_0, poly_B_0, &comb),
        || Self::compute_eval_points_quad(poly_A_1, poly_B_1, &comb),
      );

      // step branch
      let evals_s = vec![eval0_s, claim_step_round - eval0_s, eval2_s];
      let poly_s = UniPoly::from_evals(&evals_s)?;
      let coeffs_step = [poly_s.coeffs[0], poly_s.coeffs[1], poly_s.coeffs[2]];

      // core branch
      let evals_c = vec![eval0_c, claim_core_round - eval0_c, eval2_c];
      let poly_c = UniPoly::from_evals(&evals_c)?;
      let coeffs_core = [poly_c.coeffs[0], poly_c.coeffs[1], poly_c.coeffs[2]];

      verifier_circuit.inner_polys_step[j] = coeffs_step;
      verifier_circuit.inner_polys_core[j] = coeffs_core;

      // -------- transcript / witness handling --------
      let chals = SatisfyingAssignment::<E>::process_round(
        state,
        vc_shape,
        vc_ck,
        verifier_circuit,
        start_round + j,
        transcript,
      )?;
      let r_j = chals[0];
      r_y.push(r_j);

      // -------- bind polys --------
      rayon::join(
        || {
          rayon::join(
            || poly_A_0.bind_poly_var_top(&r_j),
            || poly_B_0.bind_poly_var_top(&r_j),
          );
        },
        || {
          rayon::join(
            || poly_A_1.bind_poly_var_top(&r_j),
            || poly_B_1.bind_poly_var_top(&r_j),
          );
        },
      );

      // -------- advance claim for next round --------
      claim_step_round = poly_s.evaluate(&r_j);
      claim_core_round = poly_c.evaluate(&r_j);
    }

    Ok((
      r_y,
      vec![poly_A_0[0], poly_A_1[0], poly_B_0[0], poly_B_1[0]],
    ))
  }

  /// Executes a **cubic-with-additive-term** batched outer sum-check in zero-knowledge mode
  /// and returns the sequence of verifier challenges.
  pub fn prove_cubic_with_additive_term_batched_zk(
    num_rounds: usize,
    pow_tau_left: &mut MultilinearPolynomial<E::Scalar>,
    pow_tau_right: &MultilinearPolynomial<E::Scalar>,
    poly_A_step: &mut MultilinearPolynomial<E::Scalar>,
    poly_A_core: &mut MultilinearPolynomial<E::Scalar>,
    poly_B_step: &mut MultilinearPolynomial<E::Scalar>,
    poly_B_core: &mut MultilinearPolynomial<E::Scalar>,
    poly_C_step: &mut MultilinearPolynomial<E::Scalar>,
    poly_C_core: &mut MultilinearPolynomial<E::Scalar>,
    verifier_circuit: &mut NeutronNovaVerifierCircuit<E>,
    state: &mut MultiRoundState<E>,
    vc_shape: &SplitMultiRoundR1CSShape<E>,
    vc_ck: &CommitmentKey<E>,
    transcript: &mut E::TE,
    start_round: usize,
  ) -> Result<Vec<E::Scalar>, SpartanError> {
    let mut base_tau = E::Scalar::ONE;
    let mut len_pow_tau = pow_tau_left.Z.len() * pow_tau_right.Z.len();

    let mut r_x: Vec<E::Scalar> = Vec::with_capacity(num_rounds);

    let mut claim_step = verifier_circuit.t_out_step;
    let mut claim_core = E::Scalar::ZERO;

    for i in 0..num_rounds {
      let comb = |a: &E::Scalar, b: &E::Scalar, c: &E::Scalar, d: &E::Scalar| -> E::Scalar {
        *a * (*b * *c - *d)
      };

      // step branch
      let ((mut eval0_s, mut eval2_s, mut eval3_s), (mut eval0_c, mut eval2_c, mut eval3_c)) =
        rayon::join(
          || {
            Self::compute_eval_points_cubic_with_additive_term_with_outer_pow(
              pow_tau_left,
              pow_tau_right,
              poly_A_step,
              poly_B_step,
              poly_C_step,
              &comb,
            )
          },
          || {
            Self::compute_eval_points_cubic_with_additive_term_with_outer_pow(
              pow_tau_left,
              pow_tau_right,
              poly_A_core,
              poly_B_core,
              poly_C_core,
              &comb,
            )
          },
        );

      eval0_s *= base_tau;
      eval2_s *= base_tau;
      eval3_s *= base_tau;
      eval0_c *= base_tau;
      eval2_c *= base_tau;
      eval3_c *= base_tau;

      let evals_s = vec![eval0_s, claim_step - eval0_s, eval2_s, eval3_s];
      let poly_s = UniPoly::from_evals(&evals_s)?;
      let coeffs_step = [
        poly_s.coeffs[0],
        poly_s.coeffs[1],
        poly_s.coeffs[2],
        poly_s.coeffs[3],
      ];

      let evals_c = vec![eval0_c, claim_core - eval0_c, eval2_c, eval3_c];
      let poly_c = UniPoly::from_evals(&evals_c)?;
      let coeffs_core = [
        poly_c.coeffs[0],
        poly_c.coeffs[1],
        poly_c.coeffs[2],
        poly_c.coeffs[3],
      ];

      verifier_circuit.outer_polys_step[i] = coeffs_step;
      verifier_circuit.outer_polys_core[i] = coeffs_core;

      // -------- transcript / witness handling --------
      let chals = SatisfyingAssignment::<E>::process_round(
        state,
        vc_shape,
        vc_ck,
        verifier_circuit,
        start_round + i,
        transcript,
      )?;
      let r_i = chals[0];
      r_x.push(r_i);

      // -------- advance claim and bind polys --------
      claim_step = poly_s.evaluate(&r_i);
      claim_core = poly_c.evaluate(&r_i);

      // bind polynomials to the verifier's challenge
      rayon::join(
        || {
          rayon::join(
            || poly_A_step.bind_poly_var_top(&r_i),
            || poly_A_core.bind_poly_var_top(&r_i),
          );
        },
        || {
          rayon::join(
            || {
              rayon::join(
                || poly_B_step.bind_poly_var_top(&r_i),
                || poly_B_core.bind_poly_var_top(&r_i),
              );
            },
            || {
              rayon::join(
                || poly_C_step.bind_poly_var_top(&r_i),
                || poly_C_core.bind_poly_var_top(&r_i),
              );
            },
          );
        },
      );

      // bind polynomial power of tau
      // list power of tau (pow_tau) halves effectively
      len_pow_tau >>= 1;
      let one = E::Scalar::ONE;
      let left = pow_tau_left.Z.len();
      let pow = pow_tau_left.Z[len_pow_tau % left] * pow_tau_right.Z[len_pow_tau / left];
      base_tau *= (pow - one) * r_i + one;
    }

    pow_tau_left.Z[0] = base_tau;

    Ok(r_x)
  }
}

pub(crate) mod eq_sumcheck {
  //! This module implements the sumcheck optimization for equality polynomials.
  //! The optimization is described in Section 5 of <https://eprint.iacr.org/2025/1117> algorithm 5.
  use crate::{polys::multilinear::MultilinearPolynomial, traits::Engine};
  use ff::{Field, PrimeField};
  use rayon::{iter::ZipEq, prelude::*, slice::Iter};

  pub struct EqSumCheckInstance<E: Engine> {
    // number of variables at first
    init_num_vars: usize,
    first_half: usize,
    second_half: usize,
    round: usize,
    taus: Vec<E::Scalar>,
    eval_eq_left: E::Scalar,
    poly_eq_left: Vec<Vec<E::Scalar>>,
    poly_eq_right: Vec<Vec<E::Scalar>>,
    eq_tau_0_2_3: Vec<(E::Scalar, E::Scalar, E::Scalar)>,
  }

  impl<E: Engine> EqSumCheckInstance<E> {
    /// Creates a new EqSumCheckInstance for optimized sumcheck with equality polynomials.
    ///
    /// The algorithm splits the tau vector and precomputes equality polynomial evaluations
    /// for efficient lookup during the sumcheck rounds. The round counter starts at 1 (not 0)
    /// to simplify indexing into precomputed arrays, as the first evaluation happens before
    /// any binding operations occur.
    pub fn new(taus: Vec<E::Scalar>) -> Self {
      let l = taus.len();
      let first_half = l / 2;

      let compute_eq_polynomials = |taus: Vec<&E::Scalar>| -> Vec<Vec<E::Scalar>> {
        let len = taus.len();
        let mut result = Vec::with_capacity(len + 1);

        result.push(vec![E::Scalar::ONE]);

        for i in 0..len {
          let tau = taus[i];

          let prev = &result[i];
          let mut v_next = prev.to_vec();
          v_next.par_extend(prev.par_iter().map(|v| *v * tau));
          let (first, last) = v_next.split_at_mut(prev.len());
          first.par_iter_mut().zip(last).for_each(|(a, b)| *a -= *b);

          result.push(v_next);
        }

        result
      };

      let (left_taus, right_taus) = taus.split_at(first_half);
      // Skip the first element of left_taus because the equality polynomial evaluation
      // for the first variable is tracked separately in eval_eq_left (initialized to 1).
      // This matches the Nova optimization approach where the left part is processed
      // incrementally through the bound() method rather than via lookup tables.
      let left_taus = left_taus.iter().skip(1).rev().collect::<Vec<_>>();
      let right_taus = right_taus.iter().rev().collect::<Vec<_>>();

      let (poly_eq_left, poly_eq_right) = rayon::join(
        || compute_eq_polynomials(left_taus),
        || compute_eq_polynomials(right_taus),
      );

      let f2 = E::Scalar::ONE.double();
      let f1 = E::Scalar::ONE;
      let eq_tau_0_2_3 = taus
        .par_iter()
        .map(|tau| {
          let tau2 = tau.double();
          let tau3 = tau2 + tau;
          let tau5 = tau3 + tau2;
          (f1 - tau, tau3 - f1, tau5 - f2)
        })
        .collect::<Vec<_>>();

      Self {
        init_num_vars: l,
        first_half,
        second_half: l - first_half,
        round: 1, // Start at 1 to simplify array indexing (round-1 gives 0-based index)
        taus,
        eval_eq_left: E::Scalar::ONE,
        poly_eq_left,
        poly_eq_right,
        eq_tau_0_2_3,
      }
    }

    /// Evaluate poly_A * poly_B - poly_C
    #[inline]
    pub fn evaluation_points_cubic_with_three_inputs(
      &self,
      round_idx: usize,
      poly_A: &MultilinearPolynomial<E::Scalar>,
      poly_B: &MultilinearPolynomial<E::Scalar>,
      poly_C: &MultilinearPolynomial<E::Scalar>,
    ) -> (E::Scalar, E::Scalar, E::Scalar) {
      debug_assert_eq!(poly_A.Z.len() % 2, 0);

      let in_first_half = self.round < self.first_half;

      let half_p = poly_A.Z.len() / 2;

      let [zip_A, zip_B, zip_C] = split_and_zip([&poly_A.Z, &poly_B.Z, &poly_C.Z], half_p);

      let (mut eval_0, mut eval_2, mut eval_3) = if in_first_half {
        let (poly_eq_left, poly_eq_right, second_half, low_mask) = self.poly_eqs_first_half();

        zip_A
          .zip_eq(zip_B)
          .zip_eq(zip_C)
          .enumerate()
          .map(|(id, ((a, b), c))| {
            let (zero_a, one_a) = a;
            let (zero_b, one_b) = b;
            let (zero_c, one_c) = c;

            let (eval_0, eval_2, eval_3) = eval_one_case_cubic_three_inputs(
              round_idx, zero_a, one_a, zero_b, one_b, zero_c, one_c,
            );

            let factor = poly_eq_left[id >> second_half] * poly_eq_right[id & low_mask];

            (eval_0 * factor, eval_2 * factor, eval_3 * factor)
          })
          .reduce(
            || (E::Scalar::ZERO, E::Scalar::ZERO, E::Scalar::ZERO),
            |a, b| (a.0 + b.0, a.1 + b.1, a.2 + b.2),
          )
      } else {
        let poly_eq_right = self.poly_eq_right_last_half().par_iter();

        zip_A
          .zip_eq(zip_B)
          .zip_eq(zip_C)
          .zip_eq(poly_eq_right)
          .map(|(((a, b), c), poly_eq_right)| {
            let (zero_a, one_a) = a;
            let (zero_b, one_b) = b;
            let (zero_c, one_c) = c;

            let (eval_0, eval_2, eval_3) = eval_one_case_cubic_three_inputs(
              round_idx, zero_a, one_a, zero_b, one_b, zero_c, one_c,
            );

            let factor = poly_eq_right;

            (eval_0 * factor, eval_2 * factor, eval_3 * factor)
          })
          .reduce(
            || (E::Scalar::ZERO, E::Scalar::ZERO, E::Scalar::ZERO),
            |a, b| (a.0 + b.0, a.1 + b.1, a.2 + b.2),
          )
      };

      self.update_evals(&mut eval_0, &mut eval_2, &mut eval_3);

      (eval_0, eval_2, eval_3)
    }

    #[inline]
    pub fn bound(&mut self, r: &E::Scalar) {
      // Invariant: self.round is always >= 1 when bound is called
      // as it's initialized to 1 in new() and only incremented here
      let tau = self.taus[self.round - 1];
      self.eval_eq_left *= E::Scalar::ONE - tau - r + (*r * tau).double();
      self.round += 1;
    }

    #[inline]
    fn update_evals(&self, eval_0: &mut E::Scalar, eval_2: &mut E::Scalar, eval_3: &mut E::Scalar) {
      let p = self.eval_eq_left;
      // Invariant: self.round is always >= 1 when this is called from evaluation_points methods
      let eq_tau_0_2_3 = self.eq_tau_0_2_3[self.round - 1];
      let eq_tau_0_p = eq_tau_0_2_3.0 * p;
      let eq_tau_2_p = eq_tau_0_2_3.1 * p;
      let eq_tau_3_p = eq_tau_0_2_3.2 * p;

      *eval_0 *= eq_tau_0_p;
      *eval_2 *= eq_tau_2_p;
      *eval_3 *= eq_tau_3_p;
    }

    #[inline]
    fn poly_eqs_first_half(&self) -> (&Vec<E::Scalar>, &Vec<E::Scalar>, usize, usize) {
      let second_half = self.second_half;
      // Safe indexing: This method is only called when in_first_half is true,
      // which means self.round < self.first_half. Therefore self.first_half - self.round > 0
      // and the index is valid. The poly_eq_left array has first_half+1 elements (0..=first_half).
      let poly_eq_left = &self.poly_eq_left[self.first_half - self.round];
      let poly_eq_right = &self.poly_eq_right[second_half];

      debug_assert_eq!(poly_eq_right.len(), 1 << second_half);

      (
        poly_eq_left,
        poly_eq_right,
        second_half,
        (1 << second_half) - 1,
      )
    }

    #[inline]
    fn poly_eq_right_last_half(&self) -> &Vec<E::Scalar> {
      // Safe indexing: This method is only called when in_first_half is false,
      // which means self.round >= self.first_half. The maximum value of self.round
      // is init_num_vars (as we do init_num_vars rounds), so the index is always >= 0.
      &self.poly_eq_right[self.init_num_vars - self.round]
    }
  }

  /// Splits N slices in half and creates parallel zip iterators for each half.
  ///
  /// Helper function that takes an array of slices, splits each at the midpoint,
  /// and returns an array of parallel zip iterators over the left and right halves.
  ///
  /// # Type Parameters
  /// * `N` - Number of slices to split and zip
  /// * `T` - Element type (must be `Sync` for parallel iteration)
  ///
  /// # Arguments
  /// * `vec` - Array of slices to split
  /// * `half_size` - Size of each half (should equal `vec[i].len() / 2`)
  ///
  /// # Returns
  /// Array of parallel zip iterators, one for each input slice.
  #[inline]
  fn split_and_zip<const N: usize, T: Sync>(
    vec: [&[T]; N],
    half_size: usize,
  ) -> [ZipEq<Iter<'_, T>, Iter<'_, T>>; N] {
    std::array::from_fn(|i| {
      let (left, right) = vec[i].split_at(half_size);
      left.par_iter().zip_eq(right.par_iter())
    })
  }

  /// Evaluates a cubic polynomial at points 0, 2, and 3 for three-input case.
  ///
  /// Computes evaluation points for the sum-check protocol when combining three
  /// multilinear polynomials using a cubic combination function. Uses cached
  /// evaluations at 0 and 1 to efficiently compute the required evaluation points.
  ///
  /// # Arguments
  /// * `round_idx` - Current round index in the sum-check protocol
  /// * `zero_a`, `one_a` - Evaluations of polynomial A at 0 and 1
  /// * `zero_b`, `one_b` - Evaluations of polynomial B at 0 and 1
  /// * `zero_c`, `one_c` - Evaluations of polynomial C at 0 and 1
  ///
  /// # Returns
  /// A tuple `(eval_0, eval_2, eval_3)` containing the evaluation points.
  #[inline]
  fn eval_one_case_cubic_three_inputs<Scalar: PrimeField>(
    _round_idx: usize,
    zero_a: &Scalar,
    one_a: &Scalar,
    zero_b: &Scalar,
    one_b: &Scalar,
    zero_c: &Scalar,
    one_c: &Scalar,
  ) -> (Scalar, Scalar, Scalar) {
    // Compute the evaluation at point 0
    // Note: The small-value optimization (Algorithm 6) requires the full eval_0 computation
    // to produce transcript-equivalent proofs.
    let eval_0 = *zero_a * *zero_b - *zero_c;

    let double_one_a = one_a.double();
    let double_one_b = one_b.double();
    let double_one_c = one_c.double();

    let eval_2 = {
      let point_a = double_one_a - *zero_a;
      let point_b = double_one_b - *zero_b;
      let point_c = double_one_c - *zero_c;

      point_a * point_b - point_c
    };

    let eval_3 = {
      let point_a = double_one_a + one_a - zero_a.double();
      let point_b = double_one_b + one_b - zero_b.double();
      let point_c = double_one_c + one_c - zero_c.double();
      point_a * point_b - point_c
    };

    (eval_0, eval_2, eval_3)
  }
}

pub(crate) mod lagrange_sumcheck {

  use crate::{
    accumulators::SmallValueAccumulators,
    eq_linear::EqRoundFactor,
    lagrange::{LagrangeBasisFactory, LagrangeCoeff, UdEvaluations, UdHatEvaluations},
    polys::univariate::UniPoly,
  };
  use ff::PrimeField;

  // Re-export for tests
  #[cfg(test)]
  pub(crate) use crate::eq_linear::derive_t1;

  /// Tracks the small-value sum-check state for the first ℓ₀ rounds.
  pub(crate) struct SmallValueSumCheck<Scalar: PrimeField, const D: usize> {
    accumulators: SmallValueAccumulators<Scalar, D>,
    coeff: LagrangeCoeff<Scalar, D>,
    eq_factor: EqRoundFactor<Scalar>,
    basis_factory: LagrangeBasisFactory<Scalar, D>,
  }

  impl<Scalar: PrimeField, const D: usize> SmallValueSumCheck<Scalar, D> {
    /// Create a new small-value round tracker with precomputed accumulators.
    pub(crate) fn new(
      accumulators: SmallValueAccumulators<Scalar, D>,
      basis_factory: LagrangeBasisFactory<Scalar, D>,
    ) -> Self {
      Self {
        accumulators,
        coeff: LagrangeCoeff::new(),
        eq_factor: EqRoundFactor::new(),
        basis_factory,
      }
    }

    /// Create from accumulators with the standard Lagrange basis (0, 1, 2, ...).
    pub(crate) fn from_accumulators(accumulators: SmallValueAccumulators<Scalar, D>) -> Self {
      let basis_factory = LagrangeBasisFactory::<Scalar, D>::new(|i| Scalar::from(i as u64));
      Self::new(accumulators, basis_factory)
    }

    /// Evaluate t_i(u) for all u ∈ Û_D in a single pass for round i.
    pub(crate) fn eval_t_all_u(&self, round: usize) -> UdHatEvaluations<Scalar, D> {
      self.accumulators.round(round).eval_t_all_u(&self.coeff)
    }

    /// Compute ℓ_i values for the provided w_i.
    pub(crate) fn eq_round_values(&self, w_i: Scalar) -> UdEvaluations<Scalar, 2> {
      self.eq_factor.values(w_i)
    }

    /// Advance the round state with the verifier challenge r_i.
    pub(crate) fn advance(&mut self, li: &UdEvaluations<Scalar, 2>, r_i: Scalar) {
      self.eq_factor.advance(li, r_i);
      self.coeff.extend(&self.basis_factory.basis_at(r_i));
    }
  }

  /// Build the cubic round polynomial s_i(X) in coefficient form for Spartan.
  pub(crate) fn build_univariate_round_polynomial<F: PrimeField>(
    li: &UdEvaluations<F, 2>,
    t0: F,
    t1: F,
    t_inf: F,
  ) -> UniPoly<F> {
    // Reconstruct t_i(X) = aX^2 + bX + c using:
    // - a = t_i(∞) (leading coefficient for degree-2 polynomials)
    // - c = t_i(0)
    // - t_i(1) = a + b + c ⇒ b = t_i(1) − a − c
    let a = t_inf;
    let c = t0;
    let b = t1 - a - c;

    let linf = li.at_infinity();
    let l0 = li.at_zero();

    // Multiply s_i(X) = ℓ_i(X)·t_i(X) with ℓ_i(X)=ℓ_∞X+ℓ_0 and collect coefficients.
    let s3 = linf * a;
    let s2 = linf * b + l0 * a;
    let s1 = linf * c + l0 * b;
    let s0 = l0 * c;

    UniPoly {
      coeffs: vec![s0, s1, s2, s3],
    }
  }

  /// Build s_i(0), s_i(1), s_i(2), s_i(3) for testing against the coefficient form.
  #[allow(dead_code)]
  pub(crate) fn build_univariate_round_evals<F: PrimeField>(
    li: &UdEvaluations<F, 2>,
    t0: F,
    t1: F,
    t_inf: F,
  ) -> [F; 4] {
    // Reconstruct t_i(X) = aX^2 + bX + c from t_i(∞), t_i(1), t_i(0).
    let a = t_inf;
    let c = t0;
    let b = t1 - a - c;

    // Evaluate t_i(2) = a(2)^2 + b(2) + c = 4a + 2b + c and t_i(3) = 9a + 3b + c efficiently.
    let four_a = a.double().double();
    let two_b = b.double();
    let t2 = four_a + two_b + c;

    // t_i(3) = a(3)^2 + b(3) + c = 9a + 3b + c with 9a = 8a + a and 3b = 2b + b.
    let eight_a = four_a.double();
    let nine_a = eight_a + a;
    let three_b = b.double() + b;
    let t3 = nine_a + three_b + c;

    let linf = li.at_infinity();
    let l0 = li.at_zero();
    let l1 = li.at_one();

    // Evaluate ℓ_i(2) and ℓ_i(3) from ℓ_i(X) = ℓ_∞X + ℓ_0.
    let l2 = linf.double() + l0;
    let l3 = l2 + linf;

    // Use s_i(u) = ℓ_i(u)·t_i(u) for u ∈ {0, 1, 2, 3}.
    let s0 = l0 * t0;
    let s1 = l1 * t1;
    let s2 = l2 * t2;
    let s3 = l3 * t3;

    [s0, s1, s2, s3]
  }

  #[cfg(test)]
  mod tests {
    use super::*;
    use crate::{
      accumulators::{SPARTAN_T_DEGREE, build_accumulators_spartan},
      polys::{eq::EqPolynomial, multilinear::MultilinearPolynomial},
      provider::PallasHyraxEngine,
      sumcheck::eq_sumcheck::EqSumCheckInstance,
      traits::Engine,
    };
    use ff::Field;

    type E = PallasHyraxEngine;
    type F = <E as Engine>::Scalar;

    #[test]
    fn test_round_polynomial_matches_evals() {
      let l0 = F::from(2u64);
      let linf = F::from(5u64);
      let l1 = l0 + linf;
      let li = UdEvaluations::new(linf, [l0, l1]);

      let t0 = F::from(7u64);
      let t1 = F::from(11u64);
      let t_inf = F::from(13u64);

      let poly = build_univariate_round_polynomial(&li, t0, t1, t_inf);
      let evals = build_univariate_round_evals(&li, t0, t1, t_inf);

      assert_eq!(poly.evaluate(&F::ZERO), evals[0]);
      assert_eq!(poly.evaluate(&F::ONE), evals[1]);
      assert_eq!(poly.evaluate(&F::from(2u64)), evals[2]);
      assert_eq!(poly.evaluate(&F::from(3u64)), evals[3]);
    }

    #[test]
    fn test_smallvalue_round_matches_eq_instance_evals() {
      const NUM_VARS: usize = 6;
      const SMALL_VALUE_ROUNDS: usize = 3;

      let n = 1usize << NUM_VARS;
      let taus = (0..NUM_VARS)
        .map(|i| F::from((i + 2) as u64))
        .collect::<Vec<_>>();

      let az_vals = (0..n).map(|i| F::from((i + 1) as u64)).collect::<Vec<_>>();
      let bz_vals = (0..n).map(|i| F::from((i + 3) as u64)).collect::<Vec<_>>();
      let cz_vals = az_vals
        .iter()
        .zip(bz_vals.iter())
        .map(|(a, b)| *a * *b)
        .collect::<Vec<_>>();

      let az = MultilinearPolynomial::new(az_vals);
      let bz = MultilinearPolynomial::new(bz_vals);
      let cz = MultilinearPolynomial::new(cz_vals);

      let eq_evals = EqPolynomial::evals_from_points(&taus);
      let mut claim = F::ZERO;
      for i in 0..n {
        claim += eq_evals[i] * (az.Z[i] * bz.Z[i] - cz.Z[i]);
      }

      let accs = build_accumulators_spartan(&az, &bz, &taus, SMALL_VALUE_ROUNDS);
      let mut small_value = SmallValueSumCheck::from_accumulators(accs);

      let mut eq_instance = EqSumCheckInstance::<E>::new(taus.clone());
      let mut poly_A = az.clone();
      let mut poly_B = bz.clone();
      let mut poly_C = cz.clone();

      for round in 0..SMALL_VALUE_ROUNDS {
        let (expected_eval_0, expected_eval_2, expected_eval_3) =
          eq_instance.evaluation_points_cubic_with_three_inputs(round, &poly_A, &poly_B, &poly_C);

        let li = small_value.eq_round_values(taus[round]);
        let t_all = small_value.eval_t_all_u(round);
        let t_inf = t_all.at_infinity();
        let t0 = t_all.at_zero();
        let t1 = derive_t1(li.at_zero(), li.at_one(), claim, t0)
          .expect("l1 should be non-zero for chosen taus");

        let s_evals = build_univariate_round_evals(&li, t0, t1, t_inf);
        assert_eq!(s_evals[0], expected_eval_0);
        assert_eq!(s_evals[2], expected_eval_2);
        assert_eq!(s_evals[3], expected_eval_3);

        let r_i = F::from((round + 7) as u64);
        let poly = build_univariate_round_polynomial(&li, t0, t1, t_inf);
        claim = poly.evaluate(&r_i);

        poly_A.bind_poly_var_top(&r_i);
        poly_B.bind_poly_var_top(&r_i);
        poly_C.bind_poly_var_top(&r_i);
        eq_instance.bound(&r_i);
        small_value.advance(&li, r_i);
      }
    }

    /// Test that prove_cubic_with_three_inputs_small_value produces identical
    /// output to prove_cubic_with_three_inputs for various sizes.
    fn run_equivalence_test(num_vars: usize) {
      use crate::{sumcheck::SumcheckProof, traits::transcript::TranscriptEngineTrait};

      let n = 1usize << num_vars;

      // Deterministic polynomials for reproducibility
      // Use satisfying witness: Cz = Az * Bz (so Az·Bz - Cz = 0 on boolean hypercube)
      // This is required for build_accumulators_spartan which assumes satisfaction.
      //
      // Create small i32 values
      let az_i32: Vec<i32> = (0..n).map(|i| (i + 1) as i32).collect();
      let bz_i32: Vec<i32> = (0..n).map(|i| (i + 3) as i32).collect();

      // Create field-element polynomials
      let az_vals: Vec<F> = az_i32.iter().map(|&v| F::from(v as u64)).collect();
      let bz_vals: Vec<F> = bz_i32.iter().map(|&v| F::from(v as u64)).collect();
      let cz_vals: Vec<F> = az_vals.iter().zip(&bz_vals).map(|(a, b)| *a * *b).collect();

      let taus: Vec<F> = (0..num_vars).map(|i| F::from((i + 2) as u64)).collect();

      // Claim = 0 for satisfying witness (Az·Bz = Cz on {0,1}^n)
      let claim: F = F::ZERO;

      // Polynomials for standard method
      let mut az1 = MultilinearPolynomial::new(az_vals.clone());
      let mut bz1 = MultilinearPolynomial::new(bz_vals.clone());
      let mut cz1 = MultilinearPolynomial::new(cz_vals.clone());

      // Small-value polynomials (use native integer arithmetic)
      let az_small = MultilinearPolynomial::new(az_i32);
      let bz_small = MultilinearPolynomial::new(bz_i32);

      // Field-element polynomials for binding
      let mut az2 = MultilinearPolynomial::new(az_vals);
      let mut bz2 = MultilinearPolynomial::new(bz_vals);
      let mut cz2 = MultilinearPolynomial::new(cz_vals);

      // Fresh transcripts with same seed
      let mut transcript1 = <E as Engine>::TE::new(b"test");
      let mut transcript2 = <E as Engine>::TE::new(b"test");

      // Run standard method
      let (proof1, r1, evals1) = SumcheckProof::<E>::prove_cubic_with_three_inputs(
        &claim,
        taus.clone(),
        &mut az1,
        &mut bz1,
        &mut cz1,
        &mut transcript1,
      )
      .unwrap();

      // Run small-value method
      let (proof2, r2, evals2) = SumcheckProof::<E>::prove_cubic_with_three_inputs_small_value(
        &claim,
        taus,
        &az_small,
        &bz_small,
        &mut az2,
        &mut bz2,
        &mut cz2,
        &mut transcript2,
      )
      .unwrap();

      // Verify all outputs match
      assert_eq!(r1, r2, "challenges must match for num_vars={}", num_vars);
      assert_eq!(
        proof1.compressed_polys, proof2.compressed_polys,
        "compressed_polys must match for num_vars={}",
        num_vars
      );
      assert_eq!(
        evals1, evals2,
        "final evals must match for num_vars={}",
        num_vars
      );
    }

    /// Debug test to compare first polynomial only
    #[test]
    fn test_small_value_polynomial_and_eq_instance_equivalence() {
      const NUM_VARS: usize = 10; // Same as equivalence test
      let n = 1usize << NUM_VARS;

      // Use satisfying witness: Cz = Az * Bz (required for build_accumulators_spartan)
      let az_vals: Vec<F> = (0..n).map(|i| F::from((i + 1) as u64)).collect();
      let bz_vals: Vec<F> = (0..n).map(|i| F::from((i + 3) as u64)).collect();
      let cz_vals: Vec<F> = az_vals.iter().zip(&bz_vals).map(|(a, b)| *a * *b).collect();

      let taus: Vec<F> = (0..NUM_VARS).map(|i| F::from((i + 2) as u64)).collect();

      // Claim = 0 for satisfying witness
      let claim: F = F::ZERO;

      // Create polynomials for standard method
      let az1 = MultilinearPolynomial::new(az_vals.clone());
      let bz1 = MultilinearPolynomial::new(bz_vals.clone());
      let cz1 = MultilinearPolynomial::new(cz_vals);

      // Create polynomials for small-value method
      let az2 = MultilinearPolynomial::new(az_vals);
      let bz2 = MultilinearPolynomial::new(bz_vals);

      // Run standard method - just get first polynomial's evaluations
      let eq_instance = EqSumCheckInstance::<E>::new(taus.clone());
      let (eval_0_std, eval_2_std, eval_3_std) =
        eq_instance.evaluation_points_cubic_with_three_inputs(0, &az1, &bz1, &cz1);
      let evals_std = vec![eval_0_std, claim - eval_0_std, eval_2_std, eval_3_std];

      // Run small-value method - get first polynomial's evaluations
      let l0 = 3usize;
      let accumulators = build_accumulators_spartan(&az2, &bz2, &taus, l0);
      let small_value = SmallValueSumCheck::<F, SPARTAN_T_DEGREE>::from_accumulators(accumulators);

      let t_all = small_value.eval_t_all_u(0);
      let t_inf = t_all.at_infinity();
      let t0 = t_all.at_zero();
      let li = small_value.eq_round_values(taus[0]);
      let t1 = derive_t1(li.at_zero(), li.at_one(), claim, t0).expect("l1 non-zero");

      let evals_sv = build_univariate_round_evals(&li, t0, t1, t_inf);

      // Compare evaluations
      assert_eq!(
        evals_sv[0], evals_std[0],
        "s(0) must match: sv={:?}, std={:?}",
        evals_sv[0], evals_std[0]
      );
      assert_eq!(
        evals_sv[1], evals_std[1],
        "s(1) must match: sv={:?}, std={:?}",
        evals_sv[1], evals_std[1]
      );
      assert_eq!(
        evals_sv[2], evals_std[2],
        "s(2) must match: sv={:?}, std={:?}",
        evals_sv[2], evals_std[2]
      );
      assert_eq!(
        evals_sv[3], evals_std[3],
        "s(3) must match: sv={:?}, std={:?}",
        evals_sv[3], evals_std[3]
      );
    }

    #[test]
    fn test_small_value_equivalence_l10() {
      run_equivalence_test(10); // 2^10 = 1024 elements, l0 = 3
    }

    #[test]
    fn test_small_value_equivalence_l16() {
      run_equivalence_test(16); // 2^16 = 65536 elements, l0 = 3 (must be even ℓ)
    }
  }
}
